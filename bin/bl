#!/usr/bin/env python3

"""
This script should be used as follows:

bl <package> <launchfile> <launch-args>

- Autocomplete after bl will list available ROS2 packages.
- Automcplate after <package> will list launch files (.py, .xml, .yaml, .yml) and executable files in the package.
- A dash ("-") followed by autocomplete after <launchfile> should list launch args for better_launch launch files and declared args for ROS2 launch files.

See --help and readme for further details.
"""

from typing import Any, get_args
import sys
import os
import ast
import yaml
from xml.etree import ElementTree
import click
from docstring_parser import parse as parse_docstring

from ament_index_python.packages import (
    get_packages_with_prefixes,
    get_package_prefix,
    get_package_share_directory,
)

try:
    # Jazzy
    from rclpy.parameter import get_parameter_value, parameter_value_to_python
except ImportError:
    # Humble
    from ros2param.api import (
        get_parameter_value as get_parameter_value_humble,
        get_value as get_value_humble,
    )

    get_parameter_value = lambda s: get_parameter_value_humble(string_value=s)
    parameter_value_to_python = lambda p: get_value_humble(parameter_value=p)


from better_launch import __version__
from better_launch.utils.introspection import get_launchfunc_signature_from_file
from better_launch.utils.better_logging import Colormode


class LaunchFile:
    @classmethod
    def from_file(cls, package: str, filepath: str) -> "LaunchFile":
        """Returns a LaunchFile subclass that can handle the provided launch file.

        Parameters
        ----------
        package : str
            The package the launch file lives in.
        filepath : str
            The path to the launch file.

        Returns
        -------
        LaunchFile
            An instance that can handle the provided launch file.

        Raises
        ------
        ValueError
            If no subclass could be found that can handle the provided launch file.
        """
        # Handles only immediate subclasses.
        # NOTE: by using __subclasses__ the order subclasses are defined in actually matters
        for launch_cls in LaunchFile.__subclasses__():
            try:
                return launch_cls(package, filepath)
            except ValueError:
                pass

        raise ValueError(f"{filepath} is not a valid launch file")

    def __init__(
        self,
        package: str,
        launchfile: str,
        filepath: str,
        params: list[click.Option],
        doc: str,
    ):
        """Create a representation describing the most important information about a launch file.

        Parameters
        ----------
        package : str
            The package the launch file lives in.
        launchfile : str
            The filename of the launch file.
        filepath : str
            The full path to the launch file.
        params : list[click.Option]
            ROS2 parameters that have been identified for the launch file, represented as click options.
        doc : str
            A docstring describing the launch file, if any.
        """
        self.package = package
        self.launchfile = launchfile
        self.filepath = filepath
        self.params = params
        self.doc = doc or f"{package}/{os.path.basename(launchfile)}"

    def run(self, ctx: click.Context, **kwargs) -> None:
        """Execute this launch file.
        """
        raise NotImplementedError()


class BetterLaunchFile(LaunchFile):
    """This LaunchFile will handle better_launch launch files.
    """

    @classmethod
    def _get_launch_params_and_doc_bl(
        cls, filepath: str
    ) -> tuple[list[click.Option], str]:
        if not filepath.lower().endswith(".launch.py"):
            raise ValueError("Not a python file")

        _, signature, doc = get_launchfunc_signature_from_file(filepath)
        if not signature:
            raise ValueError("Not a better_launch launch file")

        if doc:
            parsed_doc = parse_docstring(doc)
            launchfunc_doc = parsed_doc.short_description
            if parsed_doc.long_description:
                launchfunc_doc += "\n\n" + parsed_doc.long_description
            param_docstrings = {p.arg_name: p.description for p in parsed_doc.params}
        else:
            launchfunc_doc = ""
            param_docstrings = {}

        options = []
        for param in signature.parameters.values():
            default = None
            if param.default is not param.empty:
                default = param.default

            ptype = None
            if default is None and param.annotation is not param.empty:
                ptype = param.annotation
                if isinstance(ptype, str):
                    # If it's a primitive type we can parse it, otherwise ignore it
                    ptype = getattr(__builtins__, ptype, None)

            options.append(
                click.Option(
                    [f"--{param.name}"],
                    type=ptype,
                    default=default,
                    show_default=True,
                    help=param_docstrings.get(param.name, None),
                )
            )

        # NOTE these should match the overrides in wrapper.py
        options.extend([
            click.Option(
                ["--bl_ui_override"],
                type=click.types.Choice(
                    ["enable", "disable", "unset"], case_sensitive=False
                ),
                show_choices=True,
                default="unset",
                help="Override to enable/disable the terminal UI",
            ),
            click.Option(
                ["--bl_colormode_override"],
                type=click.types.Choice(
                    get_args(Colormode), case_sensitive=False
                ),
                show_choices=True,
                default=get_args(Colormode)[0],
                help="Override the logging color mode",
            )
        ])

        options.extend([
            click.Option(
                ["--remap"],
                multiple=True
            )])

        return options, launchfunc_doc

    def __init__(self, package: str, filepath: str):
        params, doc = BetterLaunchFile._get_launch_params_and_doc_bl(filepath)
        launchfile = os.path.basename(filepath)
        super().__init__(package, launchfile, filepath, params, doc)

    def run(self, ctx: click.Context, **kwargs) -> None:
        print(
            f">> Delegating to better_launch: {self.package}/{self.launchfile}, args={kwargs}",
            flush=True,
        )


        # First argument becomes argv[0], so should be the program name
        args = ["python3", self.filepath]
        for key, arg in kwargs.items():
            if arg is not None:
                args.extend([f"--{key}", arg])

        # extend args with additional python args intended for kwargs in the launch_func
        args.extend(ctx.args)
        
        # This does NOT return and will replace our executable with the new executable in the same process
        os.execvp("python3", [str(a) for a in args])


class Ros2LaunchFile(LaunchFile):
    """A LaunchFile that can handle regular ROS2 launch files (python, XML, and YAML).
    """

    @classmethod
    def _option_from_ros2_kwargs(cls, kwargs: dict[str, Any]) -> click.Option:
        def eval_arg(arg: Any) -> Any:
            try:
                return ast.literal_eval(arg)
            except Exception:
                return None

        name = eval_arg(kwargs.get("name", None))
        description = eval_arg(kwargs.get("description", None))
        default = eval_arg(kwargs.get("default_value", None))
        choices = eval_arg(kwargs.get("choices", None))

        if default:
            # Yes ROS2, I also think that simple things are boring and uninspiring...
            default = parameter_value_to_python(get_parameter_value(default))

        if choices:
            ptype = click.Choice(choices)
        else:
            ptype = type(default) if default is not None else None

        return click.Option(
            [f"--{name}"],
            type=ptype,
            help=description,
            default=default,
        )

    @classmethod
    def _get_launch_params_and_doc_ros2(
        cls, filepath: str
    ) -> tuple[list[click.Option], str]:
        if not filepath.lower().endswith(".launch.py"):
            raise ValueError("Not a python file")

        try:
            with open(filepath, "r", encoding="utf-8") as f:
                source = f.read()

            tree = ast.parse(source)
        except Exception:
            raise ValueError("Not valid python code")

        has_launch_func = False
        doc = None
        options = []

        for node in ast.walk(tree):
            if (
                isinstance(node, ast.FunctionDef)
                and node.name == "generate_launch_description"
            ):
                doc = ast.get_docstring(node)
                has_launch_func = True

            elif isinstance(node, ast.Call):
                call_name = getattr(node.func, "id", getattr(node.func, "attr", None))
                if call_name == "DeclareLaunchArgument":
                    kwargs = {key.arg: key.value for key in node.keywords if key}

                    if node.args:
                        # Passed as a positional argument
                        kwargs["name"] = node.args[0]

                    # XML and YAML are very consistent here, but DeclareLaunchArgument is... not
                    kwargs["default"] = kwargs.get("default_value", None)


                    option = cls._option_from_ros2_kwargs(kwargs)
                    options.append(option)

        if not has_launch_func:
            raise ValueError("Not a ROS2 launch file")

        return options, doc

    @classmethod
    def _get_launch_params_and_doc_xml(
        cls, filepath: str
    ) -> tuple[list[click.Option], str]:
        if not filepath.lower().endswith(".launch.xml"):
            raise ValueError("Not a python file")

        tree = ElementTree.parse(filepath)
        root = tree.getroot()

        if root.tag != "launch":
            raise ValueError("Not an xml launch file")

        args = [arg.attrib for arg in root.findall("arg")]

        options = []
        doc = ""  # Not clear how to get a comment above the root element

        for kwargs in args:
            option = cls._option_from_ros2_kwargs(kwargs)
            options.append(option)

        return options, doc

    @classmethod
    def _get_launch_params_and_doc_yaml(
        cls, filepath: str
    ) -> tuple[list[click.Option], str]:
        if not filepath.lower().endswith((".launch.yml", ".launch.yaml")):
            raise ValueError("Not a yaml file")

        with open(filepath) as f:
            content = yaml.safe_load(f)

        if "launch" not in content:
            raise ValueError("Not a yaml launch file")

        definitions: list[dict] = content["launch"]
        options = []
        doc = ""  # PyYAML does not preserve comments

        for item in definitions:
            if "arg" in item:
                # YAML might only support name and default, but who knows!
                option = cls._option_from_ros2_kwargs(item["arg"])
                options.append(option)

        return options, doc

    def __init__(self, package: str, filepath: str):
        launchfile = os.path.basename(filepath)

        for func in [
            Ros2LaunchFile._get_launch_params_and_doc_ros2,
            Ros2LaunchFile._get_launch_params_and_doc_xml,
            Ros2LaunchFile._get_launch_params_and_doc_yaml,
        ]:
            try:
                params, doc = func(filepath)
                break
            except ValueError:
                pass
        else:
            raise ValueError("Not a ROS2 launch file")

        super().__init__(package, launchfile, filepath, params, doc)

    def run(self, ctx: click.Context, **kwargs) -> None:
        print(
            f">> Delegating to ROS2 launch: {self.package}/{self.launchfile}, args={kwargs}",
            flush=True,
        )

        # First argument becomes argv[0], so should be the program name
        args = ["ros2", "launch", self.filepath]
        args.extend([f"{key}:={arg}" for key, arg in kwargs.items()])

        # This does NOT return and will replace our executable with the new executable in the same process
        os.execvp("ros2", [str(a) for a in args])


class ExecutableLaunchFile(LaunchFile):
    """A LaunchFile that handles executable files.
    """

    def __init__(self, package, filepath):
        if not os.access(filepath, os.X_OK):
            raise ValueError("Not executable")

        launchfile = os.path.basename(filepath)
        params = []
        doc = None
        super().__init__(package, launchfile, filepath, params, doc)

    def run(self, ctx: click.Context, **kwargs) -> None:
        print(
            f">> Directly executing launch file: {self.package}/{self.launchfile}, args={kwargs}",
            flush=True,
        )

        # First argument becomes argv[0], so should be the program name
        args = sys.argv[2:]

        # This does NOT return and will replace our executable with the new executable in the same process
        os.execvp(self.filepath, [str(a) for a in args])


class LaunchfileSelectionCLI(click.MultiCommand):
    def __init__(self, package: str, **kwargs):
        """This subcommand will handle selecting a launch file from the provided ROS package.

        Parameters
        ----------
        package : str
            The ROS package to search for launch files.
        """
        super().__init__(**kwargs)
        self._package = package
        self._package_path = get_package_prefix(package)

    def list_commands(self, ctx: click.Context) -> list[str]:
        executables = self._get_executables()
        executables.sort()
        return list(map(os.path.basename, executables))

    def get_command(self, ctx: click.Context, name: str) -> click.Command:
        executables = self._get_executables()
        candidates = [ex for ex in executables if os.path.basename(ex) == name]

        if not candidates:
            print(f"Launchfile {name} not found in package {self._package}")
            return None

        if len(candidates) > 1:
            print(
                f"Multiple executable files named {name} found in package {self._package}"
            )
            return None

        try:
            launchfile = LaunchFile.from_file(self._package, candidates[0])
        except ValueError:
            return None

        # return a launchfile command with launch args as its Options
        ctx.obj = {
            "launchfile": launchfile,
        }

        cmd = click.Command(
            name,
            callback=click.pass_context(launchfile.run),
            params=launchfile.params,
            help=launchfile.doc,
        )

        # In case the launch file accepts additional arguments. Unfortunately, in ROS2 this not only depends on the launch file, but also on the ROS2 node itself, specifically the allow_undeclared_parameters argument.
        cmd.ignore_unknown_options = True
        cmd.allow_extra_args = True

        return cmd

    def _get_executables(self, include_launchfiles: bool = True) -> list[str]:
        # list executable files inside our package
        if not self._package_path:
            print(f"Packge {self._package} could not be found")
            return []

        package_paths = [
            os.path.join(self._package_path, "lib", self._package),
            get_package_share_directory(self._package),
        ]
        executables = []

        for base_path in package_paths:
            for dirpath, dirnames, filenames in os.walk(base_path):
                dirnames[:] = [d for d in dirnames if not d.startswith(".")]
                dirnames.sort()

                # Look for executable files
                for filename in sorted(filenames):
                    path = os.path.join(dirpath, filename)
                    if os.access(path, os.X_OK):
                        executables.append(path)
                    elif include_launchfiles and (
                        filename.endswith((".py", ".xml", ".yaml", ".yml"))
                        and ".launch." in filename
                    ):
                        executables.append(path)

        return executables


class PackageSelectionCLI(click.MultiCommand):
    def __init__(self, **kwargs):
        """This subcommand will help in selecting a ROS package.
        """
        options = [
            click.Option(
                ["-v", "--version"],
                is_flag=True,
                callback=self.print_version,
                expose_value=False,
                is_eager=True,
            )
        ]

        super().__init__(
            params=options,
            subcommand_metavar="<package> <launchfile> [args]",
            help="""\
The better_launch launcher.

This script allows you to run both better_launch and ROS2 launch files. While using ROS2 launch should work, it would mean having an additional launch system instance running (worst case: ros2launch -> better_launch -> ros2_launch). 

In contrast to ROS2 launch, it also generates useful shell completion suggestions for packages, launch files and arguments. Launch args declared in your launch files are also recognized and will be completed (you need to type at least one dash though).
""",
            epilog="Bugs, ideas, feedback, questions? Find me at https://github.com/ndahn",
            **kwargs,
        )

    def print_version(
        self, ctx: click.Context, param: click.Parameter, value: Any
    ) -> None:
        if not value or ctx.resilient_parsing:
            return

        click.echo(__version__)
        ctx.exit()

    def list_commands(self, ctx: click.Context) -> list[str]:
        # list ROS2 packages
        return sorted(get_packages_with_prefixes().keys())

    def get_command(self, ctx: click.Context, name: str) -> click.Command:
        # return a the command that will handle selecting launch files from the package
        try:
            return LaunchfileSelectionCLI(name)
        except Exception:
            # The LaunchfileSelectionCLI will throw a PackageNotFoundError if colcon failed 
            # to install a package, and ValueError if the package name is invalid
            return None

    def format_commands(
        self, ctx: click.Context, formatter: click.HelpFormatter
    ) -> None:
        # Prevent listing ALL packages when calling without args
        pass


if __name__ == "__main__":
    # Start by selecting a package. Currently we don't provide a solution for directly executing a launch file by its path. This may be supported in the future though.
    PackageSelectionCLI().main()
